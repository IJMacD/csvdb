#include <stdlib.h>
#include <string.h>

#include "db.h"
#include "db-csv.h"
#include "db-calendar.h"
#include "db-csv-mem.h"
#include "db-sequence.h"
#include "db-sample.h"
#include "limits.h"
#include "function.h"
#include "query.h"
#include "util.h"

struct VFS VFS_Table[10] = {
    {
        0
    },
    {
        .openDB = &csv_openDB,
        .closeDB = &csv_closeDB,
        .getFieldIndex = &csv_getFieldIndex,
        .getFieldName = &csv_getFieldName,
        .getRecordValue = &csv_getRecordValue,
        .findIndex = &csv_findIndex,
    },
    {
        0
    },
    {
        .openDB = &calendar_openDB,
        .closeDB = &calendar_closeDB,
        .getFieldIndex = &calendar_getFieldIndex,
        .getFieldName = &calendar_getFieldName,
        .getRecordValue = &calendar_getRecordValue,
        .findIndex = &calendar_findIndex,
        .fullTableScan = &calendar_fullTableScan,
        .pkSearch = &calendar_pkSearch,
    },
    {
        .openDB = &csvMem_openDB,
        .closeDB = &csvMem_closeDB,
        .getFieldIndex = &csvMem_getFieldIndex,
        .getFieldName = &csvMem_getFieldName,
        .getRecordValue = &csvMem_getRecordValue,
    },
    {
        .openDB = &sequence_openDB,
        .getFieldIndex = &sequence_getFieldIndex,
        .getFieldName = &sequence_getFieldName,
        .getRecordValue = &sequence_getRecordValue,
    },
    {
        .openDB = &sample_openDB,
        .getFieldIndex = &sample_getFieldIndex,
        .getFieldName = &sample_getFieldName,
        .getRecordValue = &sample_getRecordValue,
    },
};

/**
 * @brief Try to open a database by filename
 *
 * @return 0 on success, -1 on failure
 */
int openDB (struct DB *db, const char *filename) {
    if (strcmp(filename, "CALENDAR") == 0) {
        return calendar_openDB(db, filename);
    }

    if (strncmp(filename, "SEQUENCE(", 9) == 0) {
        return sequence_openDB(db, filename);
    }

    if (strncmp(filename, "memory:", 7) == 0) {
        return csvMem_openDB(db, filename + 7);
    }

    if (strcmp(filename, "SAMPLE") == 0) {
        return sample_openDB(db, filename);
    }

    return csv_openDB(db, filename);
}

void closeDB (struct DB *db) {
    if (db == NULL) {
        return;
    }

    void (*vfs_closeDB) (struct DB *) = VFS_Table[db->vfs].closeDB;

    if (vfs_closeDB != NULL) {
        vfs_closeDB(db);
    }
}

int getFieldIndex (struct DB *db, const char *field) {
    int (*vfs_getFieldIndex) (struct DB *, const char *) = VFS_Table[db->vfs].getFieldIndex;

    if (vfs_getFieldIndex != NULL) {
        return vfs_getFieldIndex(db, field);
    }

    return -1;
}

char *getFieldName (struct DB *db, int field_index) {
    char * (*vfs_getFieldName) (struct DB *, int) = VFS_Table[db->vfs].getFieldName;

    if (vfs_getFieldName != NULL) {
        return vfs_getFieldName(db, field_index);
    }

    return NULL;
}

/**
 * Returns the number of bytes read, or -1 on error
 */
int getRecordValue (struct DB *db, int record_index, int field_index, char *value, size_t value_max_length) {
    // This is the only field we can handle generically
    if (field_index == FIELD_ROW_INDEX) {
        return sprintf(value, "%d", record_index);
    }

    int (*vfs_getRecordValue) (struct DB *, int, int, char *, size_t) = VFS_Table[db->vfs].getRecordValue;

    if (vfs_getRecordValue != NULL) {
        return vfs_getRecordValue(db, record_index, field_index, value, value_max_length);
    }

    return -1;
}

/**
 * Searches for an index file with an explict name `x` i.e. UNIQUE(x) or INDEX(x) or
 * the autogenerated name `table__field`
 * Returns 0 on failure; 1 for a regular index, 2 for unique index
 *
 * @param db struct DB * OUT - Database to populate with index (Can be NULL)
 */
int findIndex(struct DB *db, const char *table_name, const char *index_name, int index_type_flags) {
    if (strcmp(table_name, "CALENDAR") == 0) {
        return calendar_findIndex(db, table_name, index_name, index_type_flags);
    }

    if (strncmp(table_name, "SEQUENCE(", 9) == 0) {
        return sequence_findIndex(db, table_name, index_name, index_type_flags);
    }

    return csv_findIndex(db, table_name, index_name, index_type_flags);
}

/**
 * @return number of matched rows
 */
int fullTableScan (struct DB *db, struct RowList * row_list, struct Predicate *predicates, int predicate_count, int limit_value) {
    if (db->vfs == 0) {
        fprintf(stderr, "Trying to scan unititialised DB\n");
        exit(-1);
    }

    int (*vfs_fullTableScan) (struct DB *, struct RowList *, struct Predicate *, int, int) = VFS_Table[db->vfs].fullTableScan;

    if (vfs_fullTableScan != NULL) {
        return vfs_fullTableScan(db, row_list, predicates, predicate_count, limit_value);
    }

    // VFS-agnostic implementation

    char value_left[VALUE_MAX_LENGTH] = {0};
    char value_right[VALUE_MAX_LENGTH] = {0};

    for (int i = 0; i < db->record_count; i++) {
        int matching = 1;

        // Perform filtering if necessary
        for (int j = 0; j < predicate_count && matching; j++) {
            struct Predicate *predicate = predicates + j;

            evaluateFunction(value_left, db, &predicate->left, i);
            evaluateFunction(value_right, db, &predicate->right, i);

            if (!evaluateExpression(predicate->op, value_left, value_right)) {
                matching = 0;
                break;
            }
        }

        if (matching) {
            // Add to result set
            appendRowID(row_list, i);
        }

        // Implement early exit FETCH FIRST/LIMIT for cases with no ORDER clause
        if (limit_value >= 0 && row_list->row_count >= limit_value) {
            break;
        }
    }

    return row_list->row_count;
}

/**
 * A sort of dummy access function to just populate the result_rowids
 * array with all rowids in ascending numerical order.
 *
 * Equivalent to FULL TABLE SCAN with no predicates
 */
int fullTableAccess (struct DB *db, struct RowList * row_list, int limit_value) {
    if (db->vfs == 0) {
        fprintf(stderr, "Trying to access unititialised DB\n");
        exit(-1);
    }

    // VFS-agnostic implementation

    int l = db->record_count;
    if (limit_value >= 0 && limit_value < l) {
        l = limit_value;
    }

    for (int i = 0; i < l; i++) {
        appendRowID(row_list, i);
    }

    return l;
}


/**
 * @returns 0.. rowid of match; -1 if not found; -3 if below minimum; -4 if above maximum
 */
int pkSearch(struct DB *db, const char * predicate_field, const char *value) {
    if (db->vfs == 0) {
        fprintf(stderr, "Trying to PK search unititialised DB\n");
        exit(-1);
    }

    int (*vfs_pkSearch) (struct DB *, const char *, const char *) = VFS_Table[db->vfs].pkSearch;

    if (vfs_pkSearch != NULL) {
        return vfs_pkSearch(db, predicate_field, value);
    }

    // VFS-Agnostic implementation

    int pk_index = getFieldIndex(db, predicate_field);

    int index_a = 0;
    int index_b = db->record_count - 1;
    int index_match = -1;
    int numeric_mode = is_numeric(value);

    long search_value = atol(value);

    char val[VALUE_MAX_LENGTH] = {0};

    // Check boundary cases before commencing search

    // Check lower boundary
    getRecordValue(db, index_a, pk_index, val, VALUE_MAX_LENGTH);
    int res = compare(numeric_mode, value, search_value, val);

    // Search value is below minimum
    if (res < 0) {
        return -3;
    }

    // Found a match at lower boundary
    if (res == 0)
        index_match = index_a;

    else {
        // Check upper boundary
        getRecordValue(db, index_b, pk_index, val, VALUE_MAX_LENGTH);
        res = compare(numeric_mode, value, search_value, val);

        // Search value is above maximum
        if (res > 0) {
            return -4;
        }

        // Found a match at upper boundary
        if (res == 0)
            index_match = index_b;

        // Iterate as a binary search
        else while (index_a < index_b - 1) {
            int index_curr = (index_a + index_b) / 2;

            getRecordValue(db, index_curr, pk_index, val, VALUE_MAX_LENGTH);
            res = compare(numeric_mode, value, search_value, val);

            if (res == 0) {
                // printf("pk_search [%d   <%d>   %d]: %s\n", index_a, index_curr, index_b, val);
                index_match = index_curr;
                break;
            }

            if (res > 0) {
                // printf("pk_search [%d   (%d) x %d]: %s\n", index_a, index_curr, index_b, val);
                index_a = index_curr;

            } else {
                // printf("pk_search [%d x (%d)   %d]: %s\n", index_a, index_curr, index_b, val);
                index_b = index_curr;
            }
        }
    }

    if (index_match < 0) {
        return -1;
    }

    return index_match;
}